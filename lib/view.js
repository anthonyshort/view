// Generated by CoffeeScript 1.3.3
(function() {
  var View, delegate, delegateEventSplitter, event, isFunction, isObject, isString, splitEvent, toString,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  delegate = require("delegate");

  event = require("event");

  delegateEventSplitter = /^(\S+)\s*(.*)$/;

  splitEvent = function(str) {
    var match;
    match = str.match(delegateEventSplitter);
    return {
      name: match[1],
      selector: match[2]
    };
  };

  toString = Object.prototype.toString;

  isObject = function(obj) {
    return obj === Object(obk);
  };

  isString = function(obj) {
    return toString.call(obj) === '[object String]';
  };

  isFunction = function(obj) {
    return toString.call(obj) === '[object Function]';
  };

  View = (function() {
    /*
      View
      @param {Object} options Any options
    */

    function View(options) {
      this.options = options || {};
      this.events = this.options.events || this.events || {};
      this._bindings = {};
      this.subviews = [];
      this.reset(this.options.el);
      this.initialize(options);
    }

    /*
      Create a new view sub-class
    
        var MyView = View.create({
          doSomething: function(){}
        });
        var view = new MyView();
        view.doSomething();
    
      @param  {Object} obj Prototype of the new view
      @return {Function} View constructor function
    */


    View.create = function(proto) {
      var child, fn, key, parent, value;
      parent = this;
      fn = function() {};
      fn.prototype = parent.prototype;
      child = function() {
        return parent.apply(this, arguments);
      };
      child.prototype = new fn;
      child.prototype.constructor = child;
      for (key in proto) {
        value = proto[key];
        child.prototype[key] = value;
      }
      for (key in parent) {
        value = parent[key];
        child[key] = value;
      }
      return child;
    };

    /*
      Split an event string
    
        click .foo > ul
    
      into an object you can use
    */


    View.splitEvent = splitEvent;

    /*
      Simple method to mixin objects into the view. This allows
      for a bit of syntax sugar for mixins and extending views.
    
        var MyView = View.create();
        MyView.include(DraggableView);
        var view = new MyView();
        view.drag();
    
      Or with Coffeescript
    
        class MyView extends View
          @include DraggableView
    
      @param  {Object}
      @return {void}
    */


    View.include = function(obj) {
      var key, value, _results;
      _results = [];
      for (key in obj) {
        value = obj[key];
        _results.push(View.prototype[key] = value);
      }
      return _results;
    };

    /*
      The element of this view
      @type {String}
    */


    View.prototype.tagName = "div";

    /*
      Called during contruction so you don't need to override the
      actual constructor method in sub-classes
      @param  {Object} options The options passed in when creating the view
      @return {void}
    */


    View.prototype.initialize = function(options) {};

    /*
      Set the element of the view.
      @param {Element} el The new DOM element for this view
    */


    View.prototype.reset = function(element) {
      this.unbind();
      this.el = element || document.createElement(this.tagName);
      this.bind(this.events);
      return this;
    };

    /*
      Bind to an event with the given `str`, and invoke `method`:
    
        this.bind('click .remove', 'remove')
        this.bind('click .complete', 'complete')
        this.bind('dblclick .info a', 'showDetails')
        this.bind({
          'click': 'remove',
          'click .complete': 'complete'
        })
    
      @param {String} str
      @param {Function} method
      @api public
      @return {View}
    */


    View.prototype.bind = function(str, method) {
      var bound, eventData, fn, key;
      if (str === Object(str)) {
        for (key in str) {
          method = str[key];
          this.bind(key, method);
        }
      } else {
        if (isString(method)) {
          fn = this[method];
          if (!fn) {
            throw new TypeError("method \"" + method + "\" is not defined");
          }
        } else {
          fn = method;
        }
        bound = fn.bind(this);
        eventData = splitEvent(str);
        if (eventData.selector === "") {
          event.bind(this.el, eventData.name, bound);
        } else {
          delegate.bind(this.el, eventData.selector, eventData.name, bound);
        }
        this._bindings[str] = bound;
      }
      return this;
    };

    /*
      Unbind all listeners, all for a specific event, or
      a specific combination of event / selector.
    
        view.unbind()
        view.unbind('click')
        view.unbind('click .remove')
        view.unbind('click .details')
    
      @param {String} [str]
      @api public
      @return {View}
    */


    View.prototype.unbind = function(str) {
      var fn, key;
      if (str) {
        fn = this._bindings[str];
        if (!fn) {
          return;
        }
        event.unbind(this.el, splitEvent(str).name, fn);
      } else {
        for (key in this._bindings) {
          this.unbind(key);
        }
      }
      return this;
    };

    /*
      No default action. This is called when you when to prepare the view
      for insertion into the DOM and render it from a template
      @return {View}
      @api public
    */


    View.prototype.render = function() {
      return this;
    };

    /*
      Find an element matching a selector within the view
      @param  {String} selector querySelector string
      @return {Element}
    */


    View.prototype.find = function(selector) {
      return this.el.querySelector(selector);
    };

    /*
      Find all elements matching a selector within the view
      @param  {String} selector querySelector string
      @return {NodeList}
    */


    View.prototype.findAll = function(selector) {
      return this.el.querySelectorAll(selector);
    };

    /*
      Append an element to the view
      @param {Element}
      @return {View}
    */


    View.prototype.append = function(el) {
      this.el.appendChild(el);
      return this;
    };

    /*
      Set or get the HTML of the element
      @param {String}
      @return {Mixed}
    */


    View.prototype.html = function(str) {
      if (str) {
        this.el.innerHTML = str;
        return this;
      } else {
        return this.el.innerHTML;
      }
    };

    /*
      Remove and cleanup all events of this view
      @return {View}
    */


    View.prototype.destroy = function() {
      this.removeSubview();
      this.remove();
      return this;
    };

    /*
      Remove the element from the DOM
      @return {View} Fluid interface
    */


    View.prototype.remove = function() {
      var parent;
      this.unbind();
      parent = this.el.parentNode;
      if (!parent) {
        return;
      }
      parent.removeChild(this.el);
      return this;
    };

    /*
      Removes all sub-views or a single view
      @param {View} [optional] Pass in a view and only that view will be removes
      @return {View}
    */


    View.prototype.removeSubview = function(view) {
      var subview, _i, _len, _ref;
      if (view) {
        if (__indexOf.call(this.subviews, view) < 0) {
          return;
        }
        if (typeof view.destroy === "function") {
          view.destroy();
        }
        this.subviews.splice(this.subviews.indexOf(view), 1);
      } else {
        _ref = this.subviews;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subview = _ref[_i];
          this.removeSubview(subview);
        }
      }
      return this;
    };

    /*
      Add a view as a subview, this will be disposed
      of before this view is destroyed
      @param {View} view
    */


    View.prototype.addSubview = function(view) {
      return this.subviews.push(view);
    };

    return View;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = View;
  } else {
    window.View = View;
  }

}).call(this);
